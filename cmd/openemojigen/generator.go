// The CLI tool generates fetches fresh emojis from the Openemoji and saves them in data.go.
package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"text/template"
	"unicode/utf8"

	"github.com/forPelevin/gomoji"
)

const (
	outputFile = "../../data.go"
)

var (
	flagAPIKey = flag.String("apikey", "", "Openemoji API key")
)

func main() {
	flag.Parse()

	if *flagAPIKey == "" {
		log.Fatalf("invalid Openemoji API key")
	}

	s := gomoji.NewService(gomoji.NewOpenEmojiProvider(*flagAPIKey))

	emojis, err := s.AllEmojis(context.Background())
	if err != nil {
		log.Fatalf("all emojis: %s", err)
	}

	emojiMap := make(map[int32]gomoji.Emoji, len(emojis))
	for _, e := range emojis {
		r, _ := utf8.DecodeRune([]byte(e.Character))

		emojiMap[r] = e
	}

	tplFile, err := template.New("").Parse(textTplFile)
	if err != nil {
		log.Fatalf("failed to get current directory path: %s", err)
	}

	output, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("failed to create output file: %s", err)
	}

	if err = tplFile.Execute(output, emojiMap); err != nil {
		log.Fatalf("failed to execute template: %s", err)
	}

	fmt.Println("Emoji entities successfully generated")
}

const (
	textTplFile = `// Code generated by generator.go ; DO NOT EDIT.

package gomoji

var (
	emojiMap = map[int32]Emoji{
		{{ range $index, $val  := . }}
			{{ $index }}: {
				Slug:        "{{ $val.Slug }}",
				Character:   "{{ $val.Character }}",
				UnicodeName: "{{ $val.UnicodeName }}",
				CodePoint:   "{{ $val.CodePoint }}",
				Group:       "{{ $val.Group }}",
				SubGroup:    "{{ $val.SubGroup }}",
			},
		{{ end }}
	}
)`
)
